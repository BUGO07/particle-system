#version 430
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

uniform uint uWidth;
uniform uint uHeight;
uniform mat4 uCam;
uniform float uTime;
uniform bool uDebug;

layout(std430, binding = 0) buffer Particles {
    vec4 particles[];
};

layout(std430, binding = 1) buffer Velocities {
    vec4 velocities[];
};

uniform layout(binding = 3, rgba8) writeonly image2D uTexture;

const float BOX_MIN = -5.0;
const float BOX_MAX = 5.0;

bool ray_box_intersect(vec3 ray_origin, vec3 ray_dir) {
    vec3 tmin = (vec3(BOX_MIN) - ray_origin) / ray_dir;
    vec3 tmax = (vec3(BOX_MAX) - ray_origin) / ray_dir;
    vec3 t1 = min(tmin, tmax);
    vec3 t2 = max(tmin, tmax);
    float tnear = max(max(t1.x, t1.y), t1.z);
    float tfar = min(min(t2.x, t2.y), t2.z);
    return tnear <= tfar && tfar > 0.0;
}

vec3 ray_direction(float fov, vec2 uv, vec2 screen_size) {
    float aspect = screen_size.x / screen_size.y;
    vec2 ndc = 2.0 * uv - 1.0;
    float f = tan(fov * 0.5);

    vec3 forward = uCam[2].xyz;
    vec3 right = uCam[0].xyz;
    vec3 up = uCam[1].xyz;

    return normalize(forward + ndc.x * aspect * f * right + ndc.y * f * up);
}

bool sphere_intersect(vec3 ray_origin, vec3 ray_dir, vec3 center, float radius, out float t) {
    vec3 oc = ray_origin - center;
    float b = dot(oc, ray_dir);
    float c = dot(oc, oc) - radius * radius;

    if (b > 0.0 && c > 0.0) return false;

    float h = b * b - c;
    if (h < 0.0) return false;

    t = -b - sqrt(h);
    return t > 0.001;
}

void main() {
    uvec2 gid = gl_GlobalInvocationID.xy;
    if (gid.x >= uWidth || gid.y >= uHeight) return;

    vec2 uv = (vec2(gid) + 0.5) / vec2(uWidth, uHeight);
    vec3 ray_origin = uCam[3].xyz;
    vec3 ray_dir = ray_direction(radians(60.0), uv, vec2(uWidth, uHeight));

    float closest_t = 1e30;
    int hit_idx = -1;

    if (!ray_box_intersect(ray_origin, ray_dir)) {
        imageStore(uTexture, ivec2(gid), vec4(0.0, 0.0, 0.0, 1.0));
        return;
    }

    uint pCount = particles.length();

    for (uint j = 0; j < pCount; j++) {
        vec4 p = particles[j];
        float t;

        if (sphere_intersect(ray_origin, ray_dir, p.xyz, p.w, t) && t < closest_t) {
            closest_t = t;
            hit_idx = int(j);
        }
    }

    vec3 color = vec3(0.0);

    if (hit_idx >= 0) {
        vec3 hit_pos = ray_origin + ray_dir * closest_t;
        vec3 normal = normalize(hit_pos - particles[hit_idx].xyz);
        vec3 light_dir = normalize(vec3(1.0, 1.0, 0.5));

        float diff = max(dot(normal, light_dir), 0.0);
        color = vec3(0.1) + diff;

        if (uDebug) {
            vec3 vel = abs(velocities[hit_idx].xyz);
            color += vel * step(0.25, vel);
        }
    }

    imageStore(uTexture, ivec2(gid), vec4(color, 1.0));
}